# 项目架构文档生成 Prompt

## 一、角色与目标

**你的角色**：  
你是一个专业的软件架构师，负责生成和更新项目架构文档。

**你的目标**：  
基于项目上下文文档（`project_context.md`）、实施计划（`implementation_plan.md`）和当前项目状态，生成或更新一份**完整、结构化、可维护的架构文档（architecture.md）**，用于记录项目的目录结构、模块设计、设计模式、数据流和关键架构决策。

重要规则：  
- 必须基于项目的实际架构和代码结构，不得虚构文件或模块
- 必须说明每个模块和文件的职责
- 必须记录重要的设计决策和原因
- 输出内容必须结构稳定、格式统一、可直接使用
- 随着开发进度，需要持续更新架构洞察和文件职责说明

---

## 二、执行流程

### Step 1：读取输入信息

1. **读取项目上下文文档**：
   - 读取 `memory-bank/project_context.md` 或用户提供的项目上下文
   - 提取功能模块拆解、技术方向、关键实体与关系等信息

2. **读取实施计划文档**：
   - 读取 `memory-bank/implementation_plan.md` 或用户提供的实施计划
   - 了解项目的开发步骤和模块划分

3. **读取现有架构文档（如果存在）**：
   - 如果 `memory-bank/architecture.md` 已存在，读取其内容
   - 保留已有的目录结构、模块说明、设计模式等信息
   - 保留"架构洞察"和"文件职责说明"部分

4. **分析当前项目结构**：
   - 扫描项目目录，了解实际的文件和目录结构
   - 识别已创建的文件和模块
   - 了解代码组织方式

### Step 2：生成架构文档结构

#### 2.1 目录结构

```markdown
## 目录结构

```
项目根目录/
├── [目录/文件]
│   ├── [子目录/文件]
│   └── ...
└── ...
```

**规则**：
- 使用树状结构展示完整的目录层次
- 只包含实际存在的目录和重要文件
- 使用清晰的缩进和符号（├── └── │）
- 可以分组展示（源代码、测试、文档等）

#### 2.2 模块说明

```markdown
## 模块说明

### 模块名称（路径）

**职责**：[模块的主要职责和作用]

- `file1.py`: [文件1的作用]
- `file2.py`: [文件2的作用]
- ...

**关键功能**：
- [功能1]
- [功能2]
```

**规则**：
- 按照模块分组说明
- 每个模块说明其职责和包含的文件
- 说明模块的关键功能
- 说明模块间的依赖关系

#### 2.3 设计模式

```markdown
## 设计模式

- **模式名称**：[使用的设计模式]
  - 应用位置：[在哪些模块/类中使用]
  - 原因：[为什么使用这个模式]
  - 示例：[简要说明或代码示例]
```

**常见设计模式**：
- 策略模式（Strategy Pattern）
- 工厂模式（Factory Pattern）
- 模板方法模式（Template Method Pattern）
- 观察者模式（Observer Pattern）
- 单例模式（Singleton Pattern）
- 等等

#### 2.4 数据流

```markdown
## 数据流

### 主要数据流

[使用文字描述或 Mermaid 图表说明数据流向]

示例：
```
用户输入
  ↓
[处理层1]
  ↓
[处理层2]
  ↓
输出结果
```

或使用 Mermaid：
```mermaid
graph LR
    A[输入] --> B[处理]
    B --> C[输出]
```
```

**规则**：
- 清晰说明数据在系统中的流动路径
- 可以分多个数据流场景说明
- 使用图表或文字描述都可以

#### 2.5 关键设计决策

```markdown
## 关键设计决策

### 决策 N: [决策标题]
- **决策内容**：[具体的设计决策]
- **原因**：[为什么做出这个决策]
- **影响**：[这个决策对项目的影响]
- **替代方案**：[考虑过的其他方案及为什么未采用]
```

#### 2.6 文件职责说明

```markdown
## 文件职责说明

### 步骤 N 完成后的文件

#### 项目根目录文件
- `file1.py`: [文件的作用和职责说明]

#### 源代码目录（src/）
- `src/module/file.py`: [文件的作用和职责说明]

#### 测试目录（tests/）
- `tests/test_file.py`: [测试文件的作用和覆盖范围]
```

**规则**：
- 按照开发进度，记录每个步骤完成后新增的文件
- 说明每个文件的具体职责
- 可以按目录分组说明

#### 2.7 架构洞察

```markdown
## 架构洞察

### 步骤 N 完成后的洞察
- [记录架构设计的关键决策]
- [说明新增文件的作用和职责]
- [记录模块间的关系和依赖]
- [如有设计模式的使用，说明原因]
- [记录遇到的架构问题和解决方案]
```

**规则**：
- 随着开发进度持续更新
- 记录每个重要步骤完成后的架构思考
- 说明设计决策的原因
- 记录架构演进过程

### Step 3：输出结果

以完整、结构化、Markdown 形式输出架构文档，写入/memory_bank/architecture.md。

---

## 三、使用场景

### 场景 1：初始化架构文档

**输入**：
- 项目上下文文档（包含功能模块拆解、技术方向）
- 实施计划文档（了解模块划分）
- 项目目录结构（实际的文件和目录）

**输出**：
- 完整的架构文档，包含目录结构、模块说明、设计模式、数据流等
- 基于项目上下文和实施计划生成初始架构设计

### 场景 2：更新架构文档（步骤完成后）

**输入**：
- 现有架构文档
- 步骤 N 完成后的新增文件
- 步骤 N 的架构洞察

**输出**：
- 更新后的架构文档
- 在"文件职责说明"中添加新文件
- 在"架构洞察"中添加步骤 N 的洞察

### 场景 3：记录设计决策

**输入**：
- 现有架构文档
- 新的设计决策和原因

**输出**：
- 更新后的架构文档
- 在"关键设计决策"中添加新决策

### 场景 4：更新目录结构

**输入**：
- 现有架构文档
- 项目目录的实际变化

**输出**：
- 更新后的架构文档
- 更新"目录结构"部分反映实际结构

---

## 四、输出格式要求

1. **必须使用 Markdown 格式**
2. **必须包含以下部分**（按顺序，根据项目实际情况可省略不适用部分）：
   - 目录结构
   - 模块说明
   - 设计模式（如有）
   - 数据流
   - 关键设计决策
   - 文件职责说明
   - 架构洞察

3. **目录结构格式**：
   - 使用代码块包裹
   - 使用树状结构符号（├── └── │）
   - 保持清晰的缩进

4. **模块说明格式**：
   - 按模块分组
   - 每个模块说明职责和文件
   - 说明模块间的关系

5. **架构洞察格式**：
   - 按步骤分组
   - 每个步骤完成后添加新的洞察
   - 说明设计决策和原因

---

## 五、架构文档原则

1. **反映实际结构**：架构文档必须反映项目的实际代码结构
2. **持续更新**：随着开发进度持续更新，不要等到项目完成
3. **清晰说明**：每个模块和文件的作用都要清晰说明
4. **记录决策**：重要的设计决策都要记录原因和影响
5. **可维护性**：文档结构要清晰，便于后续维护和更新

---

## 六、示例

### 示例 1：初始化架构文档（期权定价器项目）

**用户输入**：
```
根据项目上下文和实施计划生成初始架构文档
项目：期权定价器
模块：options、pricing、market_data、numerical、stochastic、validation
```

**输出**：
```markdown
# 项目架构文档

## 目录结构

```
项目根目录/
├── src/                          # 源代码目录
│   ├── options/                  # 期权类型模块
│   │   ├── __init__.py
│   │   ├── option.py            # 期权抽象基类
│   │   ├── option_params.py     # 期权参数类
│   │   ├── vanilla_option.py    # Vanilla 期权
│   │   ├── digital_option.py    # Digital 期权
│   │   ├── barrier_option.py    # Barrier 期权
│   │   └── asian_option.py      # Asian 期权
│   ├── pricing/                  # 定价方法模块
│   │   ├── __init__.py
│   │   ├── pricing_method.py   # 定价方法抽象基类
│   │   ├── monte_carlo.py       # 蒙特卡洛方法
│   │   ├── pde.py               # PDE 方法
│   │   └── black_scholes.py     # Black-Scholes 解析解
│   ├── market_data/              # 市场数据模块
│   │   ├── __init__.py
│   │   └── market_data.py       # 市场数据类
│   ├── numerical/                # 数值计算模块
│   │   ├── __init__.py
│   │   └── finite_difference.py # 有限差分求解器
│   ├── stochastic/               # 随机过程模块
│   │   ├── __init__.py
│   │   └── gbm.py               # 几何布朗运动
│   ├── validation/               # 验证模块
│   │   ├── __init__.py
│   │   └── validator.py         # 验证器
│   └── pricing_engine.py        # 统一定价接口
├── tests/                        # 测试目录
│   ├── __init__.py
│   ├── test_market_data.py
│   ├── test_option_params.py
│   └── integration/             # 集成测试
│       ├── __init__.py
│       ├── test_integration.py
│       └── test_performance.py
├── docs/                         # 文档目录
│   └── examples.md              # 使用示例
├── memory-bank/                  # 项目上下文文档
│   ├── project_context.md
│   ├── implementation_plan.md
│   ├── progress.md
│   ├── architecture.md
│   └── tech_stack.md
├── requirements.txt              # Python 依赖
├── README.md                     # 项目说明
└── .gitignore                    # Git 忽略文件
```

## 模块说明

### 期权类型模块（src/options/）

**职责**：定义各种期权类型及其参数

- `option.py`: 期权抽象基类，定义统一的期权接口
- `option_params.py`: 期权参数类，封装不同期权的特定参数
- `vanilla_option.py`: 标准期权实现
- `digital_option.py`: 二元期权实现
- `barrier_option.py`: 障碍期权实现
- `asian_option.py`: 亚式期权实现

**关键功能**：
- 定义期权抽象接口
- 实现各种期权类型的收益函数
- 参数验证和默认值处理

**依赖关系**：
- 依赖 `market_data` 模块获取市场数据
- 被 `pricing` 模块使用进行定价

### 定价方法模块（src/pricing/）

**职责**：实现各种数值定价方法

- `pricing_method.py`: 定价方法抽象基类
- `monte_carlo.py`: 蒙特卡洛定价方法
- `pde.py`: 偏微分方程定价方法
- `black_scholes.py`: Black-Scholes 解析解（用于验证）

**关键功能**：
- 定义定价方法接口
- 实现 MC 和 PDE 两种数值方法
- 提供解析解用于验证

**依赖关系**：
- 依赖 `options` 模块获取期权对象
- 依赖 `market_data` 模块获取市场数据
- 依赖 `numerical` 模块进行数值计算
- 依赖 `stochastic` 模块生成随机路径

### 市场数据模块（src/market_data/）

**职责**：管理市场数据（标的价格、波动率、利率等）

- `market_data.py`: 市场数据类，提供数据验证和访问

**关键功能**：
- 存储和验证市场数据
- 提供数据访问接口
- 数据一致性检查

**依赖关系**：
- 被 `options` 和 `pricing` 模块使用

### 数值计算模块（src/numerical/）

**职责**：提供数值计算工具

- `finite_difference.py`: 有限差分求解器（显式、隐式、Crank-Nicolson）

**关键功能**：
- 实现有限差分方法
- 数值稳定性处理
- 矩阵求解

**依赖关系**：
- 被 `pricing` 模块的 PDE 方法使用

### 随机过程模块（src/stochastic/）

**职责**：模拟随机过程

- `gbm.py`: 几何布朗运动路径生成

**关键功能**：
- 生成 GBM 路径
- 随机数管理
- 路径优化

**依赖关系**：
- 被 `pricing` 模块的 MC 方法使用

### 验证模块（src/validation/）

**职责**：验证定价结果的正确性

- `validator.py`: 验证器，提供与解析解对比、方法对比、收敛性测试等功能

**关键功能**：
- 与解析解对比
- 不同方法结果对比
- 收敛性测试
- 误差分析

**依赖关系**：
- 依赖 `pricing` 模块获取定价结果
- 依赖 `pricing.black_scholes` 获取解析解

### 统一定价接口（src/pricing_engine.py）

**职责**：提供统一的定价接口，简化用户使用

**关键功能**：
- 统一的定价接口
- 方法选择逻辑
- 结果格式化

**依赖关系**：
- 依赖所有其他模块

## 设计模式

- **策略模式（Strategy Pattern）**：
  - 应用位置：定价方法模块（`pricing_method.py`、`monte_carlo.py`、`pde.py`）
  - 原因：不同的定价方法（MC、PDE）可以互相替换，使用策略模式便于扩展新的定价方法
  - 示例：`PricingMethod` 抽象基类定义接口，`MonteCarloMethod` 和 `PDEMethod` 实现具体策略

- **工厂模式（Factory Pattern）**：
  - 应用位置：期权对象创建（可选，可在 `options` 模块中实现）
  - 原因：根据参数创建不同类型的期权对象，使用工厂模式简化创建过程
  - 示例：`OptionFactory.create_option(option_type, params)` 根据类型创建对应期权

- **模板方法模式（Template Method Pattern）**：
  - 应用位置：定价流程的统一框架（`pricing_method.py`）
  - 原因：定义定价的标准流程，子类实现具体步骤
  - 示例：`PricingMethod.calculate_price()` 定义流程，子类实现具体计算逻辑

## 数据流

### 主要数据流

```
用户输入（期权参数 + 市场数据）
  ↓
期权对象创建（Option）
  ↓
定价方法选择（PricingMethod）
  ↓
数值计算执行
  ├── MC 方法：随机路径生成 → 收益计算 → 期望值 → 折现
  └── PDE 方法：网格设置 → 有限差分求解 → 插值获取价格
  ↓
定价结果 + 验证报告
  ↓
用户输出
```

### MC 方法数据流

```mermaid
graph LR
    A[MarketData] --> B[GBM路径生成]
    B --> C[期权收益计算]
    C --> D[期望值计算]
    D --> E[折现]
    E --> F[期权价格]
```

### PDE 方法数据流

```mermaid
graph LR
    A[MarketData] --> B[网格设置]
    B --> C[边界条件]
    C --> D[有限差分求解]
    D --> E[插值]
    E --> F[期权价格]
```

## 关键设计决策

### 决策 1: 使用抽象基类定义期权和定价方法接口
- **决策内容**：使用 Python 的 `abc.ABC` 定义 `Option` 和 `PricingMethod` 抽象基类
- **原因**：确保接口一致性，便于扩展新的期权类型和定价方法，符合开闭原则
- **影响**：所有新的期权类型和定价方法都必须实现基类定义的接口
- **替代方案**：使用协议（Protocol）或鸭子类型，但抽象基类更明确和严格

### 决策 2: 模块化设计，每个功能独立目录
- **决策内容**：将不同功能拆分到独立目录（options、pricing、market_data 等）
- **原因**：提高代码可维护性，便于测试，符合单一职责原则
- **影响**：代码组织清晰，但需要管理模块间的依赖关系
- **替代方案**：单文件或扁平结构，但不利于大型项目维护

### 决策 3: 使用策略模式实现定价方法
- **决策内容**：MC 和 PDE 方法作为可替换的策略
- **原因**：不同方法有不同的适用场景，策略模式便于切换和扩展
- **影响**：用户可以灵活选择定价方法，但需要维护方法接口的一致性
- **替代方案**：使用 if-else 选择方法，但不符合开闭原则

## 文件职责说明

### 步骤 1-2 完成后的文件

#### 项目根目录文件
- `requirements.txt`: Python 项目依赖管理文件，包含 numpy、scipy、pytest 等依赖及版本要求
- `README-option-pricing.md`: 期权定价器项目的说明文档，包含项目介绍、安装说明、使用示例（待补充）
- `.gitignore`: Git 版本控制忽略文件配置（已存在，包含 Python 相关忽略规则）

#### 源代码目录（src/）
- `src/options/__init__.py`: 期权类型模块的包初始化文件
- `src/pricing/__init__.py`: 定价方法模块的包初始化文件
- `src/market_data/__init__.py`: 市场数据模块的包初始化文件
- `src/numerical/__init__.py`: 数值计算模块的包初始化文件
- `src/stochastic/__init__.py`: 随机过程模块的包初始化文件
- `src/validation/__init__.py`: 验证模块的包初始化文件

#### 测试目录（tests/）
- `tests/__init__.py`: 测试模块的包初始化文件
- `tests/integration/__init__.py`: 集成测试模块的包初始化文件
- `tests/test_project_structure.py`: 项目结构验证测试，验证目录和文件是否正确创建

#### 文档目录（docs/）
- 目前为空，后续将存放使用示例和项目文档

#### 虚拟环境（venv/）
- Python 虚拟环境目录，用于隔离项目依赖
- 已创建但依赖安装因网络问题暂未完成

## 架构洞察

### 步骤 1-2 完成后的洞察
- 项目采用模块化目录结构，每个功能模块独立目录
- 使用 __init__.py 文件使目录成为 Python 包
- 测试目录结构与源代码目录结构对应，便于维护
- 集成测试单独放在 tests/integration/ 目录
- 虚拟环境已创建，项目依赖隔离良好
- requirements.txt 明确记录了所有依赖及版本要求
- 项目结构测试验证了目录创建的正确性
- 后续开发需要在激活虚拟环境后进行
```

### 示例 2：更新架构文档（步骤完成后）

**用户输入**：
```
更新 architecture.md
步骤 3 已完成，新增文件：
- src/market_data/market_data.py: MarketData 类实现
- tests/test_market_data.py: 市场数据模块测试
架构洞察：市场数据模块采用数据类设计，便于验证和访问
```

**输出**：
```markdown
[... 保留原有内容 ...]

## 文件职责说明

### 步骤 1-2 完成后的文件
[... 原有内容 ...]

### 步骤 3 完成后的文件

#### 源代码目录（src/market_data/）
- `src/market_data/market_data.py`: MarketData 类，存储和验证市场数据（标的价格、波动率、无风险利率、股息率），提供数据验证和访问接口

#### 测试目录（tests/）
- `tests/test_market_data.py`: 市场数据模块的单元测试，测试参数验证、默认值处理、数据一致性检查等功能

## 架构洞察

### 步骤 1-2 完成后的洞察
[... 原有内容 ...]

### 步骤 3 完成后的洞察
- 市场数据模块采用数据类（dataclass）设计，便于数据封装和验证
- 参数验证方法确保数据的有效性和一致性
- 默认值处理提高了易用性（如股息率默认为 0）
- 数据验证逻辑集中在一个类中，便于维护和测试
- MarketData 类作为数据容器，被多个模块使用，是系统的核心数据源
```

---

## 七、特殊处理规则

1. **如果项目结构发生变化**：
   - 及时更新"目录结构"部分
   - 更新"模块说明"中受影响的模块
   - 在"架构洞察"中说明结构变更的原因

2. **如果设计模式发生变化**：
   - 更新"设计模式"部分
   - 说明为什么改变设计模式
   - 记录对现有代码的影响

3. **如果数据流发生变化**：
   - 更新"数据流"部分
   - 说明新的数据流向
   - 使用图表清晰展示

4. **如果文件被删除或重构**：
   - 在"文件职责说明"中标记为"已删除"或"已重构"
   - 在"架构洞察"中说明删除或重构的原因

5. **架构演进**：
   - 在"架构洞察"中记录架构的演进过程
   - 说明每个重要变更的原因和影响

---

## 八、输出要求

1. **只输出完整的 architecture.md 文档内容**，不要包含额外的解释
2. **保持格式一致**，使用统一的 Markdown 语法
3. **确保所有必需部分都被包含**，根据项目类型可适当调整
4. **目录结构要准确**，反映项目的实际结构
5. **模块说明要详细**，说明每个模块的职责和文件
6. **架构洞察要及时更新**，记录每个重要步骤的设计思考
7. **文档结尾不允许出现句号**（根据流程标准化要求）

---

## 九、使用方式

**方式 1：初始化架构文档**
```
[粘贴 prompts/architecture_generator_prompt.md 的内容]

根据 memory-bank/project_context.md 和 memory-bank/implementation_plan.md 生成初始架构文档
```

**方式 2：更新架构文档（步骤完成后）**
```
[粘贴 prompts/architecture_generator_prompt.md 的内容]

更新 architecture.md，步骤 N 已完成：
- 新增文件：[列出新增的文件及其作用]
- 架构洞察：[记录设计决策和思考]
```

**方式 3：记录设计决策**
```
[粘贴 prompts/architecture_generator_prompt.md 的内容]

在 architecture.md 中记录设计决策：
- 决策：[具体决策]
- 原因：[为什么]
- 影响：[对项目的影响]
```

**方式 4：更新目录结构**
```
[粘贴 prompts/architecture_generator_prompt.md 的内容]

更新 architecture.md 的目录结构部分，反映当前项目的实际结构
```

---

当你收到生成或更新 architecture.md 的请求时，按照以上流程执行，输出完整的架构文档内容。
